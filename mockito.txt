Happy scenario
  @InjectMocks
  ErrorHandler errorHandler;
  @Mock
  MyConfig config;
  @Mock
  JmsTemplate jmsTemplate;
  
  when(config.getQueueEnabled()).thenReturn(true);
  when(config.getErrorQueue()).thenReturn("errorQueue");
  when(config.jmsTemplate()).thenReturn(jmsTemplate);
  errorHandler.processError("SOAP", "ABC123");
  verify(jmsTemplate).convertAndSend("SOAP", "ABC123");
  
Test Exception is thrown and handled (swallowed)
  when(config.getQueueEnabled()).thenReturn(true);
  when(config.getErrorQueue()).thenReturn("errorQueue");
  when(config.jmsTemplate()).thenThrow(Exception.class);
  errorHandler.processError("SOAP", "ABC123");//no exception is thrown. errorHandler.processError swallows any exceptions.

Test Exception is thrown
@Test(expected=MyException.class)
public void mytest() throw Exception {
  Exception e = new ResourceAccessException("I/O error");
  Observable o = Observable.just(e);
  when(myobj.method()).thenReturn(o);
}

MockitoJUnitRunner does not load Spring configuration. Use SpringRunner plus:
  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
  
